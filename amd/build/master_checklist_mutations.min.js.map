{"version":3,"file":"master_checklist_mutations.min.js","sources":["../src/master_checklist_mutations.js"],"sourcesContent":["import Ajax from 'core/ajax';\r\n\r\nexport default class {\r\n    masterChecklistStateEvent(stateManager, data) {\r\n\r\n    }\r\n\r\n    callDynamicForm(stateManager, data) {\r\n        const type = data.formType;\r\n        data.formData[`_qf__mod_bookit_form_edit_checklist_${type}_form`] = 1;\r\n        const formData = new URLSearchParams(data.formData).toString();\r\n\r\n        Ajax.call([{\r\n            methodname: 'core_form_dynamic_form',\r\n            args: {\r\n                formdata: formData,\r\n                form: `mod_bookit\\\\form\\\\edit_checklist_${type}_form`\r\n            }\r\n        }])[0]\r\n        .then((response) => {\r\n                stateManager.processUpdates(JSON.parse(response.data));\r\n        })\r\n        .catch(exception => {\r\n            window.console.error('AJAX error:', exception);\r\n        });\r\n\r\n    }\r\n\r\n    reOrderCategoryItems(stateManager, data) {\r\n        const state = stateManager.state;\r\n\r\n        stateManager.setReadOnly(false);\r\n\r\n        // Check if parentId and targetParentId are different\r\n        if (data.parentId !== data.targetParentId) {\r\n            // Handle moving item between different categories\r\n            const sourceCategory = state.checklistcategories.get(data.parentId);\r\n            const targetCategory = state.checklistcategories.get(data.targetParentId);\r\n\r\n            // Initialize source category items array if needed\r\n            if (!sourceCategory.items || !Array.isArray(sourceCategory.items)) {\r\n                sourceCategory.items = [];\r\n            }\r\n\r\n            // Initialize target category items array if needed\r\n            if (!targetCategory.items || !Array.isArray(targetCategory.items)) {\r\n                targetCategory.items = [];\r\n            }\r\n\r\n            const idToMove = parseInt(data.id);\r\n            const targetId = parseInt(data.targetId);\r\n\r\n            // Remove the item from the source category\r\n            sourceCategory.items = sourceCategory.items.filter(item => item !== idToMove);\r\n\r\n            // Add the item to the target category if it doesn't already exist\r\n            const targetItems = [...targetCategory.items];\r\n            const existingTargetIndex = targetItems.indexOf(idToMove);\r\n\r\n            // Only add if the item doesn't already exist in target array\r\n            if (existingTargetIndex === -1) {\r\n                const targetIndex = targetItems.indexOf(targetId);\r\n\r\n                if (targetIndex !== -1) {\r\n                    // Insert after the target ID\r\n                    targetItems.splice(targetIndex + 1, 0, idToMove);\r\n                } else {\r\n                    // If target ID not found, add to the end\r\n                    targetItems.push(idToMove);\r\n                }\r\n            }\r\n\r\n            targetCategory.items = targetItems;\r\n\r\n            const targetItem = state.checklistitems.get(idToMove);\r\n\r\n            targetItem.categoryid = parseInt(targetCategory.id);\r\n\r\n        } else {\r\n            // Same category - original logic for reordering within a category\r\n            const category = state.checklistcategories.get(data.targetParentId);\r\n\r\n            // Initialize items array if it doesn't exist or isn't iterable\r\n            if (!category.items || !Array.isArray(category.items)) {\r\n                category.items = [];\r\n            }\r\n\r\n            const currentItems = [...category.items];\r\n            const idToMove = parseInt(data.id);\r\n            const targetId = parseInt(data.targetId);\r\n\r\n            const currentIndex = currentItems.indexOf(idToMove);\r\n\r\n            // If the ID to move is not found in the array, add it at the end\r\n            if (currentIndex === -1) {\r\n                currentItems.push(idToMove);\r\n            }\r\n\r\n            // After possible addition, check if target exists\r\n            const targetIndex = currentItems.indexOf(targetId);\r\n\r\n            if (targetIndex !== -1 && currentIndex !== -1) {\r\n                // Remove the element to move\r\n                currentItems.splice(currentIndex, 1);\r\n\r\n                // Find the new target index (might have shifted if the item was removed before target)\r\n                const newTargetIndex = currentItems.indexOf(targetId);\r\n\r\n                // Insert the element after the target\r\n                currentItems.splice(newTargetIndex + 1, 0, idToMove);\r\n            } else if (currentIndex !== -1) {\r\n                // targetId doesn't exist but idToMove does - keep the current position\r\n                // No changes needed\r\n            }\r\n\r\n            // Update the items array\r\n            category.items = currentItems;\r\n\r\n        }\r\n\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    reOrderCategories(stateManager, data) {\r\n        const state = stateManager.state;\r\n\r\n        const masterChecklist = state.masterchecklists.get(1);\r\n        if (!masterChecklist) {\r\n            window.console.error('Master checklist not found');\r\n            stateManager.setReadOnly(true);\r\n            return;\r\n        }\r\n\r\n        let categoryOrder = masterChecklist.mastercategoryorder ?\r\n            masterChecklist.mastercategoryorder.split(',').map(id => parseInt(id)) : [];\r\n\r\n        const idToMove = parseInt(data.id);\r\n        const targetId = parseInt(data.targetId);\r\n\r\n        categoryOrder = categoryOrder.filter(id => id !== idToMove);\r\n\r\n        const targetIndex = categoryOrder.indexOf(targetId);\r\n\r\n        if (targetIndex !== -1) {\r\n            categoryOrder.splice(targetIndex + 1, 0, idToMove);\r\n        } else {\r\n            categoryOrder.push(idToMove);\r\n        }\r\n\r\n        const updatedCategoryOrder =  categoryOrder.join(',');\r\n\r\n        const formDataObj = {\r\n            id: data.parentId,\r\n            mastercategoryorder: updatedCategoryOrder,\r\n            action: 'put',\r\n        };\r\n\r\n        data.formData = formDataObj;\r\n        data.formType = 'master';\r\n\r\n        this.callDynamicForm(stateManager, data);\r\n    }\r\n\r\n    checklistitemCreated(stateManager, data) {\r\n        const state = stateManager.state;\r\n\r\n        stateManager.processUpdates(data);\r\n\r\n        stateManager.setReadOnly(false);\r\n        const category = state.checklistcategories.get(data[0].fields.category);\r\n        const currentItems = [...category.items];\r\n        currentItems.push(data[0].fields.id);\r\n        category.items = currentItems;\r\n        stateManager.setReadOnly(true);\r\n\r\n    }\r\n\r\n    checklistitemDeleted(stateManager, data) {\r\n        const state = stateManager.state;\r\n\r\n        stateManager.setReadOnly(false);\r\n\r\n        const category = state.checklistcategories.get(data.categoryid);\r\n\r\n        const currentItems = [...category.items];\r\n        const itemIndex = currentItems.indexOf(data.id);\r\n\r\n        if (itemIndex !== -1) {\r\n            window.console.log('item found in category items - removing');\r\n            currentItems.splice(itemIndex, 1);\r\n            category.items = currentItems;\r\n        }\r\n\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    roomChanged(stateManager, data) {\r\n        const state = stateManager.state;\r\n\r\n        stateManager.setReadOnly(false);\r\n\r\n        state.activeRoom.id = parseInt(data.id);\r\n\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    roleChanged(stateManager, data) {\r\n        const state = stateManager.state;\r\n\r\n        stateManager.setReadOnly(false);\r\n\r\n        state.activeRole.id = parseInt(data.id);\r\n\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n}"],"names":["masterChecklistStateEvent","stateManager","data","callDynamicForm","type","formType","formData","URLSearchParams","toString","call","methodname","args","formdata","form","then","response","processUpdates","JSON","parse","catch","exception","window","console","error","reOrderCategoryItems","state","setReadOnly","parentId","targetParentId","sourceCategory","checklistcategories","get","targetCategory","items","Array","isArray","idToMove","parseInt","id","targetId","filter","item","targetItems","indexOf","targetIndex","splice","push","checklistitems","categoryid","category","currentItems","currentIndex","newTargetIndex","reOrderCategories","masterChecklist","masterchecklists","categoryOrder","mastercategoryorder","split","map","updatedCategoryOrder","join","formDataObj","action","checklistitemCreated","fields","checklistitemDeleted","itemIndex","log","roomChanged","activeRoom","roleChanged","activeRole"],"mappings":"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"}