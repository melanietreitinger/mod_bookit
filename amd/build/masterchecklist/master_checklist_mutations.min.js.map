{"version":3,"file":"master_checklist_mutations.min.js","sources":["../../src/masterchecklist/master_checklist_mutations.js"],"sourcesContent":["import Ajax from 'core/ajax';\r\n\r\nexport default class {\r\n    masterChecklistStateEvent() {\r\n        // This method is intentionally empty - it's a placeholder for state events.\r\n    }\r\n\r\n    _callDynamicForm(stateManager, data, processUpdates = true) {\r\n        const type = data.formType;\r\n        data.formData[`_qf__mod_bookit_local_form_masterchecklist_edit_checklist_${type}_form`] = 1;\r\n        const formData = new URLSearchParams(data.formData).toString();\r\n\r\n        Ajax.call([{\r\n            methodname: 'core_form_dynamic_form',\r\n            args: {\r\n                formdata: formData,\r\n                form: `mod_bookit\\\\local\\\\form\\\\masterchecklist\\\\edit_checklist_${type}_form`\r\n            }\r\n        }])[0]\r\n        .then((response) => {\r\n            if (processUpdates) {\r\n                stateManager.processUpdates(JSON.parse(response.data));\r\n            }\r\n            return;\r\n        })\r\n        .catch(exception => {\r\n            window.console.error('AJAX error:', exception);\r\n        });\r\n\r\n    }\r\n\r\n    _updateChecklistItemCategory(stateManager, itemId) {\r\n        const state = stateManager.state;\r\n        const itemObject = state.checklistitems.get(itemId);\r\n\r\n        const formDataObj = {\r\n            itemid: itemObject.id,\r\n            masterid: 1,\r\n            title: itemObject.title,\r\n            categoryid: itemObject.categoryid,\r\n            roomid: itemObject.roomid,\r\n            roleid: itemObject.roleid,\r\n            action: 'put',\r\n        };\r\n\r\n        const mutationData = {\r\n            formData: formDataObj,\r\n            formType: 'item'\r\n        };\r\n\r\n        this._callDynamicForm(stateManager, mutationData, false);\r\n    }\r\n\r\n    reOrderCategoryItems(stateManager, data) {\r\n        const state = stateManager.state;\r\n\r\n        stateManager.setReadOnly(false);\r\n\r\n        // The item was moved to a different category. We need to update both categories.\r\n        if (data.parentId !== data.targetParentId) {\r\n            const sourceCategory = state.checklistcategories.get(data.parentId);\r\n            const targetCategory = state.checklistcategories.get(data.targetParentId);\r\n\r\n            if (!sourceCategory.items || !Array.isArray(sourceCategory.items)) {\r\n                sourceCategory.items = [];\r\n            }\r\n\r\n            if (!targetCategory.items || !Array.isArray(targetCategory.items)) {\r\n                targetCategory.items = [];\r\n            }\r\n\r\n            const idToMove = parseInt(data.id);\r\n            const targetId = parseInt(data.targetId);\r\n\r\n            sourceCategory.items = sourceCategory.items.filter(item => item !== idToMove);\r\n\r\n            const targetItems = [...targetCategory.items];\r\n            const existingTargetIndex = targetItems.indexOf(idToMove);\r\n\r\n            if (existingTargetIndex === -1) {\r\n                const targetIndex = targetItems.indexOf(targetId);\r\n\r\n                if (targetIndex !== -1) {\r\n                    targetItems.splice(targetIndex + 1, 0, idToMove);\r\n                } else {\r\n                    targetItems.push(idToMove);\r\n                }\r\n            }\r\n\r\n            targetCategory.items = targetItems;\r\n\r\n            const targetItem = state.checklistitems.get(idToMove);\r\n\r\n            targetItem.categoryid = parseInt(targetCategory.id);\r\n\r\n            this._updateChecklistItemCategory(stateManager, idToMove);\r\n\r\n        } else {\r\n            // The item was moved within the same category. We only need to update one category.\r\n            const category = state.checklistcategories.get(data.targetParentId);\r\n\r\n            if (!category.items || !Array.isArray(category.items)) {\r\n                category.items = [];\r\n            }\r\n\r\n            const currentItems = [...category.items];\r\n            const idToMove = parseInt(data.id);\r\n            const targetId = parseInt(data.targetId);\r\n\r\n            const currentIndex = currentItems.indexOf(idToMove);\r\n\r\n            if (currentIndex === -1) {\r\n                currentItems.push(idToMove);\r\n            }\r\n\r\n            const targetIndex = currentItems.indexOf(targetId);\r\n\r\n            if (targetIndex !== -1 && currentIndex !== -1) {\r\n                currentItems.splice(currentIndex, 1);\r\n\r\n                const newTargetIndex = currentItems.indexOf(targetId);\r\n\r\n                currentItems.splice(newTargetIndex + 1, 0, idToMove);\r\n            } else if (currentIndex !== -1) {\r\n                // Handle case where target is not found but current index exists.\r\n                currentItems.splice(currentIndex, 1);\r\n                currentItems.push(idToMove);\r\n            }\r\n\r\n            category.items = currentItems;\r\n\r\n        }\r\n\r\n        stateManager.setReadOnly(true);\r\n\r\n        const categoriesToUpdate = [];\r\n\r\n        categoriesToUpdate.push(data.targetParentId);\r\n\r\n        if (data.parentId !== data.targetParentId) {\r\n            categoriesToUpdate.push(data.parentId);\r\n        }\r\n\r\n        // Persist state changes.\r\n        categoriesToUpdate.forEach(categoryId => {\r\n            const category = stateManager.state.checklistcategories.get(categoryId);\r\n            const formDataObj = {\r\n                id: category.id,\r\n                masterid: 1,\r\n                name: category.name,\r\n                checklistitems: category.items,\r\n                action: 'put',\r\n            };\r\n\r\n            const mutationData = {\r\n                formData: formDataObj,\r\n                formType: 'category'\r\n            };\r\n\r\n            this._callDynamicForm(stateManager, mutationData, false);\r\n        });\r\n    }\r\n\r\n    reOrderCategories(stateManager, data) {\r\n        const state = stateManager.state;\r\n\r\n        const masterChecklist = state.masterchecklists.get(1);\r\n        if (!masterChecklist) {\r\n            window.console.error('Master checklist not found');\r\n            stateManager.setReadOnly(true);\r\n            return;\r\n        }\r\n\r\n        let categoryOrder = masterChecklist.mastercategoryorder ?\r\n            masterChecklist.mastercategoryorder.split(',').map(id => parseInt(id)) : [];\r\n\r\n        const idToMove = parseInt(data.id);\r\n        const targetId = parseInt(data.targetId);\r\n\r\n        categoryOrder = categoryOrder.filter(id => id !== idToMove);\r\n\r\n        const targetIndex = categoryOrder.indexOf(targetId);\r\n\r\n        if (targetIndex !== -1) {\r\n            categoryOrder.splice(targetIndex + 1, 0, idToMove);\r\n        } else {\r\n            categoryOrder.push(idToMove);\r\n        }\r\n\r\n        const updatedCategoryOrder = categoryOrder.join(',');\r\n\r\n        const formDataObj = {\r\n            id: data.parentId,\r\n            mastercategoryorder: updatedCategoryOrder,\r\n            action: 'put',\r\n        };\r\n\r\n        data.formData = formDataObj;\r\n        data.formType = 'master';\r\n\r\n        this._callDynamicForm(stateManager, data);\r\n    }\r\n\r\n    checklistitemCreated(stateManager, data) {\r\n        const state = stateManager.state;\r\n\r\n        stateManager.processUpdates(data);\r\n\r\n        stateManager.setReadOnly(false);\r\n        const category = state.checklistcategories.get(data[0].fields.category);\r\n        const currentItems = [...category.items];\r\n        currentItems.push(data[0].fields.id);\r\n        category.items = currentItems;\r\n        stateManager.setReadOnly(true);\r\n\r\n    }\r\n\r\n    checklistitemDeleted(stateManager, data) {\r\n        const state = stateManager.state;\r\n\r\n        stateManager.setReadOnly(false);\r\n\r\n        const category = state.checklistcategories.get(data.categoryid);\r\n\r\n        const currentItems = [...category.items];\r\n        const itemIndex = currentItems.indexOf(data.id);\r\n\r\n        if (itemIndex !== -1) {\r\n            currentItems.splice(itemIndex, 1);\r\n            category.items = currentItems;\r\n        }\r\n\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    roomChanged(stateManager, data) {\r\n        const state = stateManager.state;\r\n\r\n        const optionsArray = Array.from(data.options);\r\n\r\n        stateManager.setReadOnly(false);\r\n\r\n        let tempArray = [];\r\n        optionsArray.forEach(option => {\r\n            tempArray.push({\r\n                id: option.value,\r\n                name: option.textContent\r\n            });\r\n        });\r\n\r\n        const hasNoSelection = tempArray.some(room => room.id === \"0\");\r\n        if (hasNoSelection) {\r\n            tempArray = tempArray.filter(room => room.id === \"0\");\r\n        }\r\n\r\n        // Clear the existing StateMap and add new elements\r\n        state.activeRoom.clear();\r\n        tempArray.forEach((room) => {\r\n            state.activeRoom.set(room.id, room);\r\n        });\r\n\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    roleChanged(stateManager, data) {\r\n        const state = stateManager.state;\r\n\r\n        stateManager.setReadOnly(false);\r\n\r\n        state.activeRole.id = parseInt(data.id);\r\n\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n}"],"names":["masterChecklistStateEvent","_callDynamicForm","stateManager","data","processUpdates","type","formType","formData","URLSearchParams","toString","call","methodname","args","formdata","form","then","response","JSON","parse","catch","exception","window","console","error","_updateChecklistItemCategory","itemId","itemObject","state","checklistitems","get","mutationData","itemid","id","masterid","title","categoryid","roomid","roleid","action","reOrderCategoryItems","setReadOnly","parentId","targetParentId","sourceCategory","checklistcategories","targetCategory","items","Array","isArray","idToMove","parseInt","targetId","filter","item","targetItems","indexOf","targetIndex","splice","push","category","currentItems","currentIndex","newTargetIndex","categoriesToUpdate","forEach","categoryId","name","reOrderCategories","masterChecklist","masterchecklists","categoryOrder","mastercategoryorder","split","map","updatedCategoryOrder","join","formDataObj","checklistitemCreated","fields","checklistitemDeleted","itemIndex","roomChanged","optionsArray","from","options","tempArray","option","value","textContent","some","room","activeRoom","clear","set","roleChanged","activeRole"],"mappings":"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"}